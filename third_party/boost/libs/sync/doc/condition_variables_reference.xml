<?xml version="1.0" standalone="yes"?>
<library-reference id="condition_variables"><title>Condition Variables</title><header name="boost/sync/condition_variables/condition_variable.hpp">
<para>This header defines a basic condition variable primitive. </para><namespace name="boost">
<namespace name="sync">
<class name="condition_variable"><purpose>The condition variable class. </purpose><typedef name="native_handle_type"><purpose>A platform-specific type of the low level mutex implementation. </purpose><description><para><note><para>This type is only available if <computeroutput>BOOST_SYNC_DEFINES_CONDITION_VARIABLE_NATIVE_HANDLE</computeroutput> macro is defined by the library. </para>
</note>
</para></description><type>unspecified</type></typedef>
<method-group name="public member functions">
<method name="notify_one" cv="noexcept"><type>void</type><purpose>Wakes up one thread blocked on the object. </purpose></method>
<method name="notify_all" cv="noexcept"><type>void</type><purpose>Wakes up all threads blocked on the object. </purpose></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="Mutex"/>
        </template><parameter name="lock"><paramtype>unique_lock&lt; Mutex &gt; &amp;</paramtype><description><para>Lock object</para></description></parameter><purpose>Blocks the current thread on the object. </purpose><description><para>Atomically unlocks the mutex and blocks on the object. When unblocked, it locks the mutex and returns. The function can unblock upon another thread calling <computeroutput>notify_one()</computeroutput>, <computeroutput>notify_all()</computeroutput> or spuriously.</para><para>



<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The mutex is left in the locked state in case of exception. </para></description><requires><para><computeroutput>Mutex</computeroutput> is on of the mutex types compatible with <computeroutput><classname alt="boost::sync::condition_variable">condition_variable</classname></computeroutput>. </para>
</requires><requires><para><computeroutput>lock.owns_lock() == true</computeroutput> and <computeroutput>lock.mutex()</computeroutput> is locked by the current thread. </para>
</requires><requires><para>There are no other threads blocked on the object or the blocked threads used the same mutex returned by <computeroutput>lock.mutex()</computeroutput> to block on this object.</para>
</requires></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="Mutex"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="lock"><paramtype>unique_lock&lt; Mutex &gt; &amp;</paramtype><description><para>Lock object </para></description></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>Condition predicate</para></description></parameter><purpose>Blocks the current thread on the object until the predicate is satisfied. </purpose><description><para>Works equivalent to:</para><para><computeroutput> while (!pred()) wait(lock); </computeroutput></para><para>



<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The mutex is left in the locked state in case of exception. </para></description><requires><para><computeroutput>Mutex</computeroutput> is on of the mutex types compatible with <computeroutput><classname alt="boost::sync::condition_variable">condition_variable</classname></computeroutput>. </para>
</requires><requires><para><computeroutput>lock.owns_lock() == true</computeroutput> and <computeroutput>lock.mutex()</computeroutput> is locked by the current thread. </para>
</requires><requires><para>There are no other threads blocked on the object or the blocked threads used the same mutex returned by <computeroutput>lock.mutex()</computeroutput> to block on this object.</para>
</requires></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="Mutex"/>
          <template-type-parameter name="Time"/>
        </template><parameter name="lock"><paramtype>unique_lock&lt; Mutex &gt; &amp;</paramtype><description><para>Lock object </para></description></parameter><parameter name="timeout"><paramtype>Time const &amp;</paramtype><description><para>Relative or absolute timeout. If timeout is relative, the time is measured according to the system clock.</para></description></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Atomically unlocks the mutex and blocks on the object. When unblocked, it locks the mutex and returns. The function can unblock after the specified timeout expires, upon another thread calling <computeroutput>notify_one()</computeroutput>, <computeroutput>notify_all()</computeroutput> or spuriously, whichever happens first. The timeout can be specified as an absolute time point or duration.</para><para>




<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The mutex is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description><requires><para><computeroutput>Mutex</computeroutput> is on of the mutex types compatible with <computeroutput><classname alt="boost::sync::condition_variable">condition_variable</classname></computeroutput>. </para>
</requires><requires><para><computeroutput>lock.owns_lock() == true</computeroutput> and <computeroutput>lock.mutex()</computeroutput> is locked by the current thread. </para>
</requires><requires><para>There are no other threads blocked on the object or the blocked threads used the same mutex returned by <computeroutput>lock.mutex()</computeroutput> to block on this object.</para>
</requires><returns><para><computeroutput>true</computeroutput> if the function returned before the timeout expired, otherwise <computeroutput>false</computeroutput>.</para>
</returns></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="Mutex"/>
          <template-type-parameter name="Time"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="lock"><paramtype>unique_lock&lt; Mutex &gt; &amp;</paramtype><description><para>Lock object </para></description></parameter><parameter name="timeout"><paramtype>Time const &amp;</paramtype><description><para>Relative or absolute timeout. If timeout is relative, the time is measured according to the system clock. </para></description></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>Condition predicate</para></description></parameter><purpose>Blocks the current thread on the object until the predicate is satisfied or the timeout expires. </purpose><description><para>If the timeout is an absolute time point, works equivalent to:</para><para><computeroutput> while (!pred()) if (!timed_wait(lock, timeout)) return pred(); </computeroutput></para><para>otherwise works as if equivalent to:</para><para><computeroutput> auto abs_timeout = chrono::system_clock::now() + timeout; while (!pred()) if (!timed_wait(lock, abs_timeout)) return pred(); </computeroutput></para><para>



<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The mutex is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description><requires><para><computeroutput>Mutex</computeroutput> is on of the mutex types compatible with <computeroutput><classname alt="boost::sync::condition_variable">condition_variable</classname></computeroutput>. </para>
</requires><requires><para><computeroutput>lock.owns_lock() == true</computeroutput> and <computeroutput>lock.mutex()</computeroutput> is locked by the current thread. </para>
</requires><requires><para>There are no other threads blocked on the object or the blocked threads used the same mutex returned by <computeroutput>lock.mutex()</computeroutput> to block on this object.</para>
</requires></method>
<method name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="Mutex"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>unique_lock&lt; Mutex &gt; &amp;</paramtype><description><para>Lock object </para></description></parameter><parameter name="rel_timeout"><paramtype>Duration const &amp;</paramtype></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Atomically unlocks the mutex and blocks on the object. When unblocked, it locks the mutex and returns. The function can unblock after the specified timeout expires, upon another thread calling <computeroutput>notify_one()</computeroutput>, <computeroutput>notify_all()</computeroutput> or spuriously, whichever happens first. The timeout must be specified as a time duration.</para><para>




<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The mutex is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description><requires><para><computeroutput>Mutex</computeroutput> is on of the mutex types compatible with <computeroutput><classname alt="boost::sync::condition_variable">condition_variable</classname></computeroutput>. </para>
</requires><requires><para><computeroutput>lock.owns_lock() == true</computeroutput> and <computeroutput>lock.mutex()</computeroutput> is locked by the current thread. </para>
</requires><requires><para>There are no other threads blocked on the object or the blocked threads used the same mutex returned by <computeroutput>lock.mutex()</computeroutput> to block on this object.</para>
</requires><returns><para><computeroutput>cv_status::no_timeout</computeroutput> if the function returned before the timeout expired, otherwise <computeroutput>cv_status::timeout</computeroutput>.</para>
</returns></method>
<method name="wait_for"><type>bool</type><template>
          <template-type-parameter name="Mutex"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="lock"><paramtype>unique_lock&lt; Mutex &gt; &amp;</paramtype><description><para>Lock object </para></description></parameter><parameter name="rel_timeout"><paramtype>Duration const &amp;</paramtype></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>Condition predicate</para></description></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Works equivalent to:</para><para><computeroutput> return wait_until(lock, chrono::system_clock::now() + rel_timeout, pred); </computeroutput></para><para>



<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The mutex is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description><requires><para><computeroutput>Mutex</computeroutput> is on of the mutex types compatible with <computeroutput><classname alt="boost::sync::condition_variable">condition_variable</classname></computeroutput>. </para>
</requires><requires><para><computeroutput>lock.owns_lock() == true</computeroutput> and <computeroutput>lock.mutex()</computeroutput> is locked by the current thread. </para>
</requires><requires><para>There are no other threads blocked on the object or the blocked threads used the same mutex returned by <computeroutput>lock.mutex()</computeroutput> to block on this object.</para>
</requires></method>
<method name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="Mutex"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>unique_lock&lt; Mutex &gt; &amp;</paramtype><description><para>Lock object </para></description></parameter><parameter name="abs_timeout"><paramtype>TimePoint const &amp;</paramtype></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Atomically unlocks the mutex and blocks on the object. When unblocked, it locks the mutex and returns. The function can unblock after the specified timeout expires, upon another thread calling <computeroutput>notify_one()</computeroutput>, <computeroutput>notify_all()</computeroutput> or spuriously, whichever happens first. The timeout must be specified as an absolute time point.</para><para>




<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The mutex is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description><requires><para><computeroutput>Mutex</computeroutput> is on of the mutex types compatible with <computeroutput><classname alt="boost::sync::condition_variable">condition_variable</classname></computeroutput>. </para>
</requires><requires><para><computeroutput>lock.owns_lock() == true</computeroutput> and <computeroutput>lock.mutex()</computeroutput> is locked by the current thread. </para>
</requires><requires><para>There are no other threads blocked on the object or the blocked threads used the same mutex returned by <computeroutput>lock.mutex()</computeroutput> to block on this object.</para>
</requires><returns><para><computeroutput>cv_status::no_timeout</computeroutput> if the function returned before the timeout expired, otherwise <computeroutput>cv_status::timeout</computeroutput>.</para>
</returns></method>
<method name="wait_until"><type>bool</type><template>
          <template-type-parameter name="Mutex"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="lock"><paramtype>unique_lock&lt; Mutex &gt; &amp;</paramtype><description><para>Lock object </para></description></parameter><parameter name="abs_timeout"><paramtype>TimePoint const &amp;</paramtype></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>Condition predicate</para></description></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Works equivalent to:</para><para><computeroutput> while (!pred()) if (wait_until(lock, timeout) == cv_status::timeout) return pred(); </computeroutput></para><para>



<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The mutex is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description><requires><para><computeroutput>Mutex</computeroutput> is on of the mutex types compatible with <computeroutput><classname alt="boost::sync::condition_variable">condition_variable</classname></computeroutput>. </para>
</requires><requires><para><computeroutput>lock.owns_lock() == true</computeroutput> and <computeroutput>lock.mutex()</computeroutput> is locked by the current thread. </para>
</requires><requires><para>There are no other threads blocked on the object or the blocked threads used the same mutex returned by <computeroutput>lock.mutex()</computeroutput> to block on this object.</para>
</requires></method>
<method name="native_handle" cv="noexcept"><type>native_handle_type</type><purpose>Returns a handle that represents a native operating system primitive that implements the condition variable. </purpose><description><para><note><para>This method is only available if <computeroutput>BOOST_SYNC_DEFINES_CONDITION_VARIABLE_NATIVE_HANDLE</computeroutput> macro is defined by the library. </para>
</note>
</para></description></method>
</method-group>
<constructor><purpose>Default constructor. </purpose><description><para><emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to create the primitive (e.g. due to insufficient resources). </para></description></constructor>
<destructor><purpose>Destructor. </purpose><description><para>Destroys the condition variable.</para><para>
</para></description><requires><para>There are no threads blocked on the object. </para>
</requires></destructor>
<constructor cv="= delete"><parameter name=""><paramtype><classname>condition_variable</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= delete"><type><classname>condition_variable</classname> &amp;</type><parameter name=""><paramtype><classname>condition_variable</classname> const &amp;</paramtype></parameter></copy-assignment>
</class>
</namespace>
</namespace>
</header>
<header name="boost/sync/condition_variables/condition_variable_any.hpp">
<para>This header defines a basic condition variable primitive. </para><namespace name="boost">
<namespace name="sync">
<class name="condition_variable_any"><purpose>The condition variable class. </purpose><method-group name="public member functions">
<method name="notify_one"><type>void</type><purpose>Wakes up one thread blocked on the object. </purpose></method>
<method name="notify_all"><type>void</type><purpose>Wakes up all threads blocked on the object. </purpose></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="Lock"/>
        </template><parameter name="lock"><paramtype>Lock &amp;</paramtype><description><para>Lock object. Must be a model of <computeroutput>BasicLockable</computeroutput>.</para></description></parameter><purpose>Blocks the current thread on the object. </purpose><description><para>Atomically unlocks the lock and blocks on the object. When unblocked, it locks the lock and returns. The function can unblock upon another thread calling <computeroutput>notify_one()</computeroutput>, <computeroutput>notify_all()</computeroutput> or spuriously.</para><para>
<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The lock is left in the locked state in case of exception. </para></description></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="Lock"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="lock"><paramtype>Lock &amp;</paramtype><description><para>Lock object. Must be a model of <computeroutput>BasicLockable</computeroutput>. </para></description></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>Condition predicate.</para></description></parameter><purpose>Blocks the current thread on the object until the predicate is satisfied. </purpose><description><para>Works equivalent to:</para><para><computeroutput> while (!pred()) wait(lock); </computeroutput></para><para>
<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The mutex is left in the locked state in case of exception. </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="Lock"/>
          <template-type-parameter name="Time"/>
        </template><parameter name="lock"><paramtype>Lock &amp;</paramtype><description><para>Lock object. Must be a model of <computeroutput>BasicLockable</computeroutput>. </para></description></parameter><parameter name="timeout"><paramtype>Time const &amp;</paramtype><description><para>Relative or absolute timeout. If timeout is relative, the time is measured according to the system clock.</para></description></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Atomically unlocks the lock and blocks on the object. When unblocked, it locks the lock and returns. The function can unblock after the specified timeout expires, upon another thread calling <computeroutput>notify_one()</computeroutput>, <computeroutput>notify_all()</computeroutput> or spuriously, whichever happens first. The timeout can be specified as an absolute time point or duration.</para><para>

<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The lock is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description><returns><para><computeroutput>true</computeroutput> if the function returned before the timeout expired, otherwise <computeroutput>false</computeroutput>.</para>
</returns></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="Lock"/>
          <template-type-parameter name="Time"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="lock"><paramtype>Lock &amp;</paramtype><description><para>Lock object. Must be a model of <computeroutput>BasicLockable</computeroutput>. </para></description></parameter><parameter name="timeout"><paramtype>Time const &amp;</paramtype><description><para>Relative or absolute timeout. If timeout is relative, the time is measured according to the system clock. </para></description></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>Condition predicate.</para></description></parameter><purpose>Blocks the current thread on the object until the predicate is satisfied or the timeout expires. </purpose><description><para>If the timeout is an absolute time point, works equivalent to:</para><para><computeroutput> while (!pred()) if (!timed_wait(lock, timeout)) return pred(); </computeroutput></para><para>otherwise works as if equivalent to:</para><para><computeroutput> auto abs_timeout = chrono::system_clock::now() + timeout; while (!pred()) if (!timed_wait(lock, abs_timeout)) return pred(); </computeroutput></para><para>
<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The lock is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description></method>
<method name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="Lock"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>Lock &amp;</paramtype><description><para>Lock object. Must be a model of <computeroutput>BasicLockable</computeroutput>. </para></description></parameter><parameter name="rel_timeout"><paramtype>Duration const &amp;</paramtype></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Atomically unlocks the lock and blocks on the object. When unblocked, it locks the lock and returns. The function can unblock after the specified timeout expires, upon another thread calling <computeroutput>notify_one()</computeroutput>, <computeroutput>notify_all()</computeroutput> or spuriously, whichever happens first. The timeout must be specified as a time duration.</para><para>

<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The lock is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description><returns><para><computeroutput>cv_status::no_timeout</computeroutput> if the function returned before the timeout expired, otherwise <computeroutput>cv_status::timeout</computeroutput>.</para>
</returns></method>
<method name="wait_for"><type>bool</type><template>
          <template-type-parameter name="Lock"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="lock"><paramtype>Lock &amp;</paramtype><description><para>Lock object. Must be a model of <computeroutput>BasicLockable</computeroutput>. </para></description></parameter><parameter name="rel_timeout"><paramtype>Duration const &amp;</paramtype></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>Condition predicate.</para></description></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Works equivalent to:</para><para><computeroutput> return wait_until(lock, chrono::system_clock::now() + rel_timeout, pred); </computeroutput></para><para>
<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The lock is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description></method>
<method name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="Lock"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>Lock &amp;</paramtype><description><para>Lock object. Must be a model of <computeroutput>BasicLockable</computeroutput>. </para></description></parameter><parameter name="abs_timeout"><paramtype>TimePoint const &amp;</paramtype></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Atomically unlocks the lock and blocks on the object. When unblocked, it locks the lock and returns. The function can unblock after the specified timeout expires, upon another thread calling <computeroutput>notify_one()</computeroutput>, <computeroutput>notify_all()</computeroutput> or spuriously, whichever happens first. The timeout must be specified as an absolute time point.</para><para>

<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The lock is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description><returns><para><computeroutput>cv_status::no_timeout</computeroutput> if the function returned before the timeout expired, otherwise <computeroutput>cv_status::timeout</computeroutput>.</para>
</returns></method>
<method name="wait_until"><type>bool</type><template>
          <template-type-parameter name="Lock"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="lock"><paramtype>Lock &amp;</paramtype><description><para>Lock object. Must be a model of <computeroutput>BasicLockable</computeroutput>. </para></description></parameter><parameter name="abs_timeout"><paramtype>TimePoint const &amp;</paramtype></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>Condition predicate.</para></description></parameter><purpose>Blocks the current thread on the object until the timeout expires. </purpose><description><para>Works equivalent to:</para><para><computeroutput> while (!pred()) if (wait_until(lock, timeout) == cv_status::timeout) return pred(); </computeroutput></para><para>
<emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to fulfill the request. The lock is left in the locked state in case of exception.</para><para><note><para>In order to use this method, a supplementary header must be included from boost/sync/support to enable support for particular time units. </para>
</note>
</para></description></method>
</method-group>
<constructor><purpose>Default constructor. </purpose><description><para><emphasis role="bold">Throws:</emphasis> An exception in case if the operating system is unable to create the primitive (e.g. due to insufficient resources). </para></description></constructor>
<destructor><purpose>Destructor. </purpose><description><para>Destroys the condition variable.</para><para>
</para></description><requires><para>There are no threads blocked on the object. </para>
</requires></destructor>
<constructor cv="= delete"><parameter name=""><paramtype><classname>condition_variable_any</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= delete"><type><classname>condition_variable_any</classname> &amp;</type><parameter name=""><paramtype><classname>condition_variable_any</classname> const &amp;</paramtype></parameter></copy-assignment>
</class>
</namespace>
</namespace>
</header>
<header name="boost/sync/condition_variables/cv_status.hpp">
<para>This header defines <computeroutput>cv_status</computeroutput> enumeration. </para><namespace name="boost">
<namespace name="sync">
<enum name="cv_status"><enumvalue name="no_timeout"><purpose>The operation completed successfully before timeout. </purpose></enumvalue><enumvalue name="timeout"><purpose>Timeout expired. </purpose></enumvalue><purpose>Condition variable wait status. </purpose></enum>

</namespace>
</namespace>
</header>
<header name="boost/sync/condition_variables/notify_all_at_thread_exit.hpp">
<para>This header defines the <computeroutput>notify_all_at_thread_exit</computeroutput> function. </para><namespace name="boost">
<namespace name="sync">
<function name="notify_all_at_thread_exit"><type>void</type><parameter name="cond"><paramtype><classname>sync::condition_variable</classname> &amp;</paramtype><description><para>Condition variable to perform notification on. </para></description></parameter><parameter name="lock"><paramtype>sync::unique_lock&lt; sync::mutex &gt;</paramtype><description><para>The lock that owns the mutex, used to block on the condition variable.</para></description></parameter><description><para>Schedules a notification of the condition variable at the calling thread termination. The notification shall be performed with the <computeroutput>cond.notify_all()</computeroutput> method shortly before the thread terminates.</para><para>The provided lock must be locked, its ownership is transferred to an external storage until the notification is performed. If there are threads blocked on the <emphasis>cond</emphasis> object, these threads should have used the same mutex object as the one referred to by the <emphasis>lock</emphasis>.</para><para>


</para></description><requires><para><computeroutput>lock.owns_lock()</computeroutput> </para>
</requires><postconditions><para><computeroutput>!lock.owns_lock()</computeroutput> </para>
</postconditions></function>
</namespace>
</namespace>
</header>
</library-reference>